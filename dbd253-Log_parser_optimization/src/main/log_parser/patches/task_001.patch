diff --git a/repository_before/LogParser.java b/repository_after/LogParser.java
index 4ac885b..684e459 100644
--- a/repository_before/LogParser.java
+++ b/repository_after/LogParser.java
@@ -1,20 +1,52 @@
 package com.logparser;
 
-import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class LogParser {
-    // Original unoptimized logic as per prompt
-    public static List<String> parseLogs(List<String> lines) {
-        List<String> errors = new ArrayList<>();
+
+    /**
+     * Parses the log lines, extracts distinct error tokens (e.g., ERROR_TIMEOUT),
+     * and counts their occurrences.
+     *
+     * Optimization:
+     * - Uses String.indexOf("ERROR") to find potential error tokens quickly.
+     * - Avoids splitting strings entirely.
+     * - Uses a single pass per line.
+     * - Extracts token by reading from "ERROR" index until whitespace.
+     * 
+     * @param lines List of log lines
+     * @return Map of ErrorType -> Count
+     */
+    public static Map<String, Integer> parseLogs(List<String> lines) {
+        Map<String, Integer> errorCounts = new HashMap<>();
+
+        if (lines == null) {
+            return errorCounts;
+        }
+
         for (String line : lines) {
-            String[] parts = line.split(" ");
-            for (String p : parts) {
-                if (p.contains("ERROR")) {
-                    errors.add(line);
+            if (line == null || line.isEmpty()) {
+                continue;
+            }
+
+            // Fast search for "ERROR"
+            int errorIndex = line.indexOf("ERROR");
+            if (errorIndex != -1) {
+                // We found "ERROR". Now extracting the full token.
+                
+                int len = line.length();
+                int endIndex = errorIndex;
+                
+                while (endIndex < len && !Character.isWhitespace(line.charAt(endIndex))) {
+                    endIndex++;
                 }
+                
+                String token = line.substring(errorIndex, endIndex);
+                errorCounts.merge(token, 1, Integer::sum);
             }
         }
-        return errors;
+        return errorCounts;
     }
 }
